#!/usr/bin/env python3
"""
inspect_d2i.py

Small helper to inspect a .d2i file generated by the project.
It will:
 - read bytes
 - show file size and hex preview
 - convert each byte to bits assuming LSB-first ordering
 - print the bit string (truncated) and then parse 9-bit property IDs
   until end-marker 511 is reached (or file ends)

Usage: python3 inspect_d2i.py path/to/file.d2i
"""

import sys
import os

END_MARKER = 0x1FF  # 9 bits all ones = 511


def byte_to_bits_lsb_first(b):
    # return string of 8 characters '0'/'1', LSB at index 0
    return ''.join('1' if (b >> i) & 1 else '0' for i in range(8))


def bytes_to_bitstring_lsb(data: bytes) -> str:
    return ''.join(byte_to_bits_lsb_first(b) for b in data)


def parse_9bit_ids_from_bitstring(bitstring: str):
    ids = []
    i = 0
    while i + 9 <= len(bitstring):
        chunk = bitstring[i:i+9]
        # chunk[0] is LSB of ID, chunk[8] is MSB â€” compute value
        val = 0
        for bit_index, ch in enumerate(chunk):
            if ch == '1':
                val |= (1 << bit_index)
        ids.append((i, val))
        i += 9
        if val == END_MARKER:
            break
    return ids, i


def main():
    if len(sys.argv) < 2:
        print('Usage: inspect_d2i.py file.d2i')
        return 1

    path = sys.argv[1]
    if not os.path.exists(path):
        print('File not found:', path)
        return 2

    data = open(path, 'rb').read()
    size = len(data)
    print(f'File: {path}')
    print(f'Size: {size} bytes')
    print('Hex preview (first 64 bytes):')
    print(data[:64].hex(' '))

    bitstring = bytes_to_bitstring_lsb(data)
    print('\nBitstring length:', len(bitstring))
    print('Bitstring preview (first 256 bits):')
    print(bitstring[:256])

    ids, consumed_bits = parse_9bit_ids_from_bitstring(bitstring)
    print(f'Parsed {len(ids)} 9-bit IDs (consumed {consumed_bits} bits)')
    for offset, idval in ids[:50]:
        marker = '<END>' if idval == END_MARKER else ''
        print(f'bit offset {offset:4d}: id={idval:3d} {marker}')

    if ids and ids[-1][1] == END_MARKER:
        print('\nEnd-marker found at bit offset', ids[-1][0])
    else:
        print('\nEnd-marker NOT found. Parsed IDs truncated or not present.')

    # Sliding search: try every bit offset within first 1024 bits (or full file) to locate the end-marker
    max_search_bits = min(len(bitstring), 1024)
    found_offsets = []
    for start in range(0, max_search_bits):
        if start + 9 > len(bitstring):
            break
        val = 0
        for bit_index in range(9):
            if bitstring[start + bit_index] == '1':
                val |= (1 << bit_index)
        if val == END_MARKER:
            found_offsets.append(start)
            break

    if found_offsets:
        print('\nSliding search: End-marker found at bit offset(s):', found_offsets)
    else:
        print('\nSliding search: End-marker NOT found within first', max_search_bits, 'bits')

    return 0


if __name__ == '__main__':
    sys.exit(main())
